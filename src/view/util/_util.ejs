<%
getUtil = function () {
  return {

    type: (type, obj) => {
      if (typeof obj === 'undefined') return false;
      var tp = Object.prototype.toString.call(obj).replace(/^\[object (.+)\]$/, '$1').toLowerCase();
      return obj !== undefined && obj !== null && tp === type;
    },

    hasModifier: (modifiers, checkString) => {
      if (util.type('array', modifiers)) {
        return modifiers.join('').indexOf(checkString) !== -1;
      }
      if (util.type('string', modifiers)) {
        return modifiers.indexOf(checkString) !== -1;
      }
      throw new Error(typeof modifiers);
    },

    hasNoModifier: (modifiers) => {
      const modifierArray = modifiers;
      if (util.type('string', modifier)) {
        modifierArray = modifiers.replace(/\s+/, ' ').replace(/\s$/, '').modifiers.split(' ');
      }

      let result = true;
      modifierArray.forEach((string) => {
        if (string.match(/^(i|j)s-/) === null && string !== '') {
          result = false;
        }
      });

      return result;
    },

    setModifierString: (name, modifier) => {
      // ignore 'is-*', 'js-*', '*__*' rule
      if (modifier.match(/(^(i|j)s-)|(^.*?__)/) !== null) {
        return modifier;
      }

      if (modifier === ' ' || modifier === '') {
        return;
      }

      return name + '--' + modifier;
    },

    setModifierArray: (name, modifiers) => {
      return modifiers
        .map(function (element) {
          return util.setModifierString(name, element);
        })
        .join(' ');
    },

    checkSpace: (name, string) => {
      if (string.indexOf(' ') === -1) {
        return util.setModifierString(name, string);
      }
      return util.setModifierArray(name, string.split(' '));
    },

    setModifier: (name, modifier) => {
      if (util.type('string', modifier)) {
        if (modifier === '') {
          return '';
        }
        return ' ' + util.checkSpace(name, modifier);
      }

      if (util.type('array', modifier)) {
        if (modifier === []) {
          return '';
        }
        return ' ' + util.setModifierArray(name, modifier);
      }
    },

    floatFormat: (number, n) => {
      const _pow = Math.pow(10, n);
      return Math.round(number * _pow) / _pow;
    },

    inc: (EjsRoot, blockName, options = {}) => {
      const p = {};
      p[`${blockName.replace(/[-_]([a-z])/g, (g) => { return g[1].toUpperCase(); })}Params`] = options;
      return [`${EjsRoot}components/${blockName}/_${blockName}`, p];
    },

    init: () => {
      return (util, componentParams, defaultParams, dataParams) => {
        // check currently used param value
        const currentParams = {};
        const params = componentParams;

        if (util.type('object', params)) {
          // Pick same property of defaultParams from componentParams.params
          for (const p in defaultParams) {
            if (typeof params[p] !== 'undefined')
              currentParams[p] = params[p];
          }
        }

        // Merge parameter values
        // currentParams > dataParams > defaultParams
        return Object.assign({}, defaultParams, dataParams, currentParams);
      }
    },

    printAttr: (attr, val) => {
      if (!util.type('string', val) || !util.type('string', attr)) {
        throw new Error('"val and attr" must be a string!');
      }
      if (val === 'undefined') {
        return '###ERROR###';
      }
      if (val === '') {
        return '';
      }
      return ` ${attr}="${val}"`;
    }

  };
};
%>
